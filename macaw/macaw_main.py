# macaw_main.py
'''
Perform a series of tests on a given Cobrapy Model object to identify reactions
that may have some errors in their definition/construction (e.g. duplicates of
other reactions, incorrect reversibility, part of dead-ends) and suggest ways to
fix at least some of these (potential) errors
'''

from macaw.macaw_structural import dead_end_test, duplicate_test, diphosphate_test
from macaw.macaw_flux_based import loop_test, dilution_test
from macaw.macaw_utils import simplify_test_results, add_reaction_equations
import networkx as nx
import pandas as pd

def run_all_tests(
    model,
    # only required for the redox portion of duplicate_test; will just skip that
    # bit without raising an exception if not provided
    redox_pairs = list(), proton_ids = list(),
    # only required for the reversible diphosphate test; will just skip without
    # raising an exception if not provided
    diphosphate_met_ids = list(), phosphate_met_ids = list(),
    # optional parameters for dilution_test and/or loop_test
    media_mets = None, timeout = 1800, max_retries = 3, zero_thresh = 10**-8,
    corr_thresh = 0.9,
    # arguments affecting how the reaction equation column in the table of test
    # results are created: with metabolite IDs (default) or names (use_names =
    # True), and whether or not to add suffixes to those IDs or names indicating
    # the compartment the metabolite is in (default is to not)
    use_names = False, add_suffixes = False,
    # only the dilution and loop tests can be run in parallel, but they can
    # really benefit from multiple threads
    threads = 1,
    # control whether or not the tests print progress updates (0 to silence)
    verbose = 1
):
    # identify all dead-end reactions and reactions that are nominally
    # reversible but only actually capable of sustaining flux in a single
    # direction
    (dead_end_results, dead_end_edges) = dead_end_test(
        model, use_names, add_suffixes, verbose
    )
    # identify sets of reactions that are potentially duplicates of each other
    (duplicates, dupe_edges) = duplicate_test(
        model, redox_pairs, proton_ids, use_names, add_suffixes, verbose
    )
    # identify all reversible reactions that involve diphosphate that aren't
    # transporting it between compartments cuz they should probably be
    # irreversible (only if lists of IDs of metabolites representing diphosphate
    # and phosphate were provided)
    diphosphates = diphosphate_test(
        model, diphosphate_met_ids, phosphate_met_ids, use_names, add_suffixes,
        verbose
    )
    # identify reactions that are capable of sustaining non-zero fluxes when all
    # exchange reactions are blocked
    (loops, loop_edges) = loop_test(
        model, zero_thresh, corr_thresh, use_names, add_suffixes, threads,
        verbose
    )
    # identify reactions that become incapable of sustaining non-zero fluxes
    # when dilution constraints are added to the model
    (dilution_results, dilution_edges) = dilution_test(
        model, dead_end_results, media_mets, zero_thresh, timeout, max_retries,
        use_names, add_suffixes, verbose, threads
    )
    # merge the dataframes containing the results of all tests (dead-end and
    # dilution test results were already merged into dilution_test_results)
    all_test_results = duplicates.merge(diphosphates).merge(loops)
    all_test_results = all_test_results.merge(dilution_results)
    # if verbose isn't 0, print the number of reactions flagged by at least one
    # test
    simple_results = simplify_test_results(all_test_results)
    flagged_rxns = simple_results[
        simple_results.loc[
            :, simple_results.columns.str.contains('test')
        ].apply(lambda col: col != 'ok', axis = 1).any(axis = 1)
    ]['reaction_id']
    if verbose > 0:
        msg = f'{len(flagged_rxns)} of the {len(model.reactions)} reactions in '
        msg += 'the given GSMM were flagged by at least one of the tests.'
        print(msg)
    # combine the edge lists and add edges between reactions flagged by
    # different tests. also add a column to the test results indicating which
    # "pathway" (connected component of the network) each reaction winds up in
    (all_test_results, edge_list) = form_pathways(
        all_test_results, model, dilution_edges + dead_end_edges,
        dupe_edges + loop_edges, use_names, add_suffixes
    )
    return((all_test_results, edge_list))

def form_pathways(
    test_results, model, met_rxn_edges, rxn_rxn_edges,
    use_names = False, add_suffixes = False
):
    '''
    Given:
        - a set of tuples of metabolite and reaction IDs generated by the
          dead-end and/or dilution tests (or an empty list)
        - a set of tuples of pairs of reaction IDs generated by the duplicate
          test (or an empty list)
        - the results of one or more other tests
        - the Cobrapy Model object those tests were run on
    Return a Pandas Dataframe with a "source" and "target" column representing
    an edge list of a network connecting reactions flagged by the various tests.
    Note that many reactions flagged by one or more tests may not wind up
    connected to any other reactions.
    '''
    # start by getting all metabolite and reaction IDs that appear in the given
    # metabolite-reaction edge list
    mets = {e[0] for e in met_rxn_edges}
    rxns = {e[1] for e in met_rxn_edges}
    # then add new edges to the metabolite-reaction edge list between all
    # reactions that were flagged by any test and metabolites they involve that
    # are already present in that edge list
    simple_results = simplify_test_results(test_results)
    flagged_reactions = simple_results[simple_results.loc[
        :, simple_results.columns.str.contains('test')
    ].apply(lambda col: col != 'ok', axis = 1).any(axis = 1)]['reaction_id']
    rxns.update(flagged_reactions.to_list())
    # also add edges to any reactions in the reaction-reaction edge lists
    rxns.update({e[0] for e in rxn_rxn_edges})
    rxns.update({e[1] for e in rxn_rxn_edges})
    # coerce to set so we can avoid adding duplicate edges easily
    met_rxn_edges = set(met_rxn_edges)
    for rxn_id in rxns:
        for met in model.reactions.get_by_id(rxn_id).metabolites:
            if (met.id in mets):
                met_rxn_edges.add((met.id, rxn_id))
    # replace all the metabolite-reaction edges with reaction-reaction edges
    # between all reactions that share at least one metabolite (only considering
    # the metabolites present in the metabolite-reaction edge list to avoid
    # connecting all reactions that involve water, protons, ATP, etc.)
    bip_graph = nx.from_edgelist(met_rxn_edges)
    rxn_graph = nx.algorithms.bipartite.projected_graph(
        bip_graph, [n for n in bip_graph if n in rxns]
    )
    edge_df = nx.to_pandas_edgelist(rxn_graph)
    # now we can concatenate this edge list with the given reaction-reaction
    # edge list
    edge_df = pd.concat([
        edge_df, nx.to_pandas_edgelist(nx.from_edgelist(rxn_rxn_edges))
    ]).drop_duplicates()
    # enumerate the connected components of this graph and add a column to the
    # given test results with these numbers so that reactions can be grouped
    # by the "pathway" that they're in
    pathway_dict = {r.id : 0 for r in model.reactions}
    i = 0
    for pathway in nx.connected_components(rxn_graph):
        i += 1
        for reaction_id in pathway:
            pathway_dict[reaction_id] = i
    test_results['pathway'] = test_results['reaction_id'].map(pathway_dict)
    return((test_results, edge_df))
